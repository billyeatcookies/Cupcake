{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cupcake Editor \ud83e\uddc1","text":"<p>Cupcake is a code editor that can be embedded in tkinter applications, with syntax highlighting support for over 500+ programming languages, autocompletions, minimap, and many more editing features. The codebase was extracted from the Biscuit project and published as an embeddable widget library. Scroll down to see cupcake in action.</p> <ul> <li>Syntax Highlighting - Over 500+ languages supported</li> <li>Auto completions - Words and keywords</li> <li>Customizable - Custom themes and fonts</li> <li>Diff Viewer - Side-by-side comparison of files, integrate with Git</li> <li>Minimap - Overview of the code, for quick navigation</li> <li>Breadcrumbs - Pathview tree</li> <li>Image Viewer - View images in the editor</li> </ul> <p></p> <pre><code>import tkinter as tk\nfrom cupcake import Editor, Languages\n\nroot = tk.Tk()\n\ne = Editor(root, language=Languages.TYPESCRIPT)\ne.pack(expand=1, fill=tk.BOTH)\ne.content.insert(\n    \"end\",\n    \"\"\"// check this out\nimport \"./global.css\";\nimport App from './App.svelte';\n\nconst app = new App({\n    target: document.body\n});\n\nexport default app;\n\"\"\",\n)\n\nroot.mainloop()\n</code></pre> <p>For more examples like Diff viewer, Image viewer, Custom Theming, see /examples.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install cupcake-editor\n</code></pre>"},{"location":"#the-editor-component","title":"The Editor Component","text":"<p>Picks the right editor based on the path, path2, diff values passed. Supports showing diff, images, text files. If no arguments are passed, empty text editor is opened.</p>"},{"location":"#attributes","title":"Attributes","text":"option type description field type master <code>tk.Widget</code> The parent tkinter widget mandatory path <code>str</code> Absolute path to the file to be opened optional path2 <code>str</code> Absolute path to be opened in right hand side (if diff) optional diff <code>bool</code> Whether to be opened in diffviewer optional language <code>cupcake.Language</code> This is given priority while picking suitable highlighter. If not passed, guesses from file extension. optional dark_mode <code>bool</code> Sets the editor theme to cupcake dark if True, or cupcake light by default. This is ignored if custom config_file path is passed optional config_file <code>str</code> Absolute path to the custom config (TOML) file, uses theme defaults if not passed. see examples optional showpath <code>bool</code> Whether to show the breadcrumbs for editor or not optional font <code>str</code>/<code>tk.font.Font</code> Font used in line numbers, text editor, autocomplete. defaults to Consolas(11) optional uifont <code>str</code>/<code>tk.font.Font</code> Font used for other UI components (breadcrumbs, trees) optional preview_file_callback <code>function</code>/<code>lambda</code> Called when files in breadcrumbs-pathview are single-clicked. MUST take an argument (path) optional open_file_callback <code>function</code>/<code>lambda</code> Called when files in breadcrumbs-pathview are double clicked. MUST take an argument (path) optional"},{"location":"#methods","title":"Methods","text":"function description <code>Editor.save</code> If the content is editable writes to the specified path. <code>Editor.focus</code> Gives focus to the content. <p>Additionally, All the tk.Text widget methods are available under Editor.content (eg. <code>Editor.content.insert</code>, <code>Editor.content.get</code>)</p>"},{"location":"#features","title":"Features","text":"<ul> <li> Auto Indentation</li> <li> Diff Viewer</li> <li> Minimap</li> <li> Breadcrumbs and Pathview tree</li> <li> Image Viewer</li> <li> Fully Customizable and themable configurations</li> <li> Language Detection from File Extensions</li> <li> Default dark/light mode themes</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Your contributions and support are greatly appreciated! \ud83e\udde1 See contributing for further details such as coding guidelines and tools used.</p>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#editor","title":"Editor","text":"<p>               Bases: <code>Frame</code></p> <p>Editor class Picks the right editor based on the path, path2, diff values passed. Supports showing diff, images, text files. If nothing is passed, empty text editor is opened.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path of the file to be opened</p> <code>None</code> <code>path2</code> <code>str</code> <p>path of file to be opened in diff, required if diff=True is passed</p> <code>None</code> <code>diff</code> <code>bool</code> <p>whether this is to be opened in diff editor</p> <code>False</code> <code>language</code> <code>str</code> <p>Use the <code>Languages</code> enum provided (eg. Languages.PYTHON, Languages.TYPESCRIPT) This is given priority while picking suitable highlighter. If not passed, guesses from file extension.</p> <code>None</code> <code>dark_mode</code> <p>Sets the editor theme to cupcake dark if True, or cupcake light by default This is ignored if custom config_file path is passed</p> required <code>config_file</code> <code>str</code> <p>path to the custom config (TOML) file, uses theme defaults if not passed</p> <code>None</code> <code>showpath</code> <code>bool</code> <p>whether to show the breadcrumbs for editor or not</p> <code>True</code> <code>font</code> <code>str | Font</code> <p>Font used in line numbers, text editor, autocomplete. defaults to Consolas(11)</p> <code>None</code> <code>uifont</code> <code>str | Font</code> <p>Font used for other UI components (breadcrumbs, trees)</p> <code>None</code> <code>preview_file_callback</code> <code>Callable</code> <p>called when files in breadcrumbs-pathview are single clicked. MUST take an argument (path)</p> <code>None</code> <code>open_file_callback</code> <code>Callable</code> <p>called when files in breadcrumbs-pathview are double clicked. MUST take an argument (path)</p> <code>None</code> <p>NOTE: All the standard tk.Text methods and properties are available under Editor.content (eg. Editor.content.insert, Editor.content.get)</p> <p>Methods:</p> Name Description <code>save</code> <p>If the content is editable writes to the specified path.</p> <code>focus</code> <p>Gives focus to the content.</p> Source code in <code>cupcake\\__init__.py</code> <pre><code>class Editor(Frame):\n    \"\"\"\n    Editor class\n    Picks the right editor based on the path, path2, diff values passed. Supports showing diff, images, text files.\n    If nothing is passed, empty text editor is opened.\n\n    Args:\n        path: path of the file to be opened\n        path2: path of file to be opened in diff, required if diff=True is passed\n        diff: whether this is to be opened in diff editor\n        language: Use the `Languages` enum provided (eg. Languages.PYTHON, Languages.TYPESCRIPT)\n            This is given priority while picking suitable highlighter. If not passed, guesses from file extension.\n        dark_mode: Sets the editor theme to cupcake dark if True, or cupcake light by default\n            This is ignored if custom config_file path is passed\n        config_file: path to the custom config (TOML) file, uses theme defaults if not passed\n        showpath:  whether to show the breadcrumbs for editor or not\n        font:  Font used in line numbers, text editor, autocomplete. defaults to Consolas(11)\n        uifont: Font used for other UI components (breadcrumbs, trees)\n        preview_file_callback: called when files in breadcrumbs-pathview are single clicked. MUST take an argument (path)\n        open_file_callback:  called when files in breadcrumbs-pathview are double clicked. MUST take an argument (path)\n\n\n    NOTE: All the standard *tk.Text* methods and properties are available under *Editor.content* (eg. Editor.content.insert, Editor.content.get)\n\n    Methods:\n        save: If the content is editable writes to the specified path.\n        focus: Gives focus to the content.\n    \"\"\"\n\n    def __init__(\n        self,\n        master,\n        path: str = None,\n        path2: str = None,\n        diff: bool = False,\n        language: str = None,\n        darkmode=True,\n        config_file: str = None,\n        showpath: bool = True,\n        font: str | Font = None,\n        uifont: str | Font = None,\n        preview_file_callback: typing.Callable = None,\n        open_file_callback: typing.Callable = None,\n        *args,\n        **kwargs\n    ) -&gt; None:\n        super().__init__(master, *args, **kwargs)\n\n        self.path = path\n        self.path2 = path2\n        self.diff = diff\n        self.showpath = showpath\n        self.darkmode = darkmode\n        self.config_file = config_file\n        self.preview_file_callback = preview_file_callback\n        self.open_file_callback = open_file_callback\n\n        self.settings = Config(self, config_file, darkmode, font, uifont)\n        self.theme = self.settings.theme\n\n        self.config(bg=self.theme.border)\n        self.grid_columnconfigure(0, weight=1)\n\n        self.content = get_editor(self, path, path2, diff, language)\n        self.filename = os.path.basename(self.path) if path else None\n        if path and self.showpath and not diff:\n            self.breadcrumbs = BreadCrumbs(self, path)\n            self.grid_rowconfigure(1, weight=1)\n            self.breadcrumbs.grid(row=0, column=0, sticky=tk.EW, pady=(0, 1))\n            self.content.grid(row=1, column=0, sticky=tk.NSEW)\n        else:\n            self.grid_rowconfigure(0, weight=1)\n            self.content.grid(row=0, column=0, sticky=tk.NSEW)\n\n    def save(self, path: str = None) -&gt; None:\n        \"\"\"Saves the content to the specified path\n\n        Args:\n            path (str, optional): path to save the content. Defaults to None.\n        \"\"\"\n        self.content.save(path)\n\n    def focus(self) -&gt; None:\n        \"\"\"Gives focus to the content\"\"\"\n\n        self.content.focus()\n</code></pre>"},{"location":"api-reference/#cupcake.Editor.focus","title":"<code>focus()</code>","text":"<p>Gives focus to the content</p> Source code in <code>cupcake\\__init__.py</code> <pre><code>def focus(self) -&gt; None:\n    \"\"\"Gives focus to the content\"\"\"\n\n    self.content.focus()\n</code></pre>"},{"location":"api-reference/#cupcake.Editor.save","title":"<code>save(path=None)</code>","text":"<p>Saves the content to the specified path</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path to save the content. Defaults to None.</p> <code>None</code> Source code in <code>cupcake\\__init__.py</code> <pre><code>def save(self, path: str = None) -&gt; None:\n    \"\"\"Saves the content to the specified path\n\n    Args:\n        path (str, optional): path to save the content. Defaults to None.\n    \"\"\"\n    self.content.save(path)\n</code></pre>"},{"location":"api-reference/#diff-editor","title":"Diff Editor","text":"<p>               Bases: <code>BaseEditor</code></p> <p>DiffEditor class.</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <p>Parent widget.</p> required <code>path1</code> <code>str</code> <p>Path to the first file.</p> required <code>path2</code> <code>str</code> <p>Path to the second file.</p> required <code>language</code> <p>Language to use for syntax highlighting.</p> <code>None</code> Source code in <code>cupcake\\diffeditor\\__init__.py</code> <pre><code>class DiffEditor(BaseEditor):\n    \"\"\"DiffEditor class.\n\n    Args:\n        master: Parent widget.\n        path1: Path to the first file.\n        path2: Path to the second file.\n        language: Language to use for syntax highlighting.\n    \"\"\"\n\n    def __init__(self, master, path1: str, path2: str, language=None, *args, **kwargs):\n        super().__init__(master, *args, **kwargs)\n        self.config(bg=self.base.theme.border)\n        self.grid_columnconfigure(0, weight=1)\n        self.grid_columnconfigure(1, weight=1)\n        self.grid_rowconfigure(0, weight=1)\n        self.path1 = path1\n        self.path2 = path2\n        self.editable = True\n\n        self.lhs_data = []\n        self.rhs_data = []\n\n        self.lhs_last_line = 0\n        self.rhs_last_line = 0\n\n        self.lhs = DiffPane(self, path1, language=language)\n        self.lhs.grid(row=0, column=0, sticky=tk.NSEW, padx=(0, 1))\n\n        self.rhs = DiffPane(self, path2, language=language)\n        self.rhs.grid(row=0, column=1, sticky=tk.NSEW)\n\n        self.left = self.lhs.text\n        self.right = self.text = self.rhs.text\n\n        self.lhs.scrollbar[\"command\"] = self.on_scrollbar\n        self.rhs.scrollbar[\"command\"] = self.on_scrollbar\n        self.left[\"yscrollcommand\"] = self.on_textscroll\n        self.right[\"yscrollcommand\"] = self.on_textscroll\n\n        self.stipple = self.base.settings.stipple\n\n        self.left.tag_config(\n            \"addition\",\n            background=self.base.theme.diffeditor.notexist,\n            bgstipple=f\"@{self.stipple}\",\n        )\n        self.left.tag_config(\"removal\", background=self.base.theme.diffeditor.removed)\n        self.left.tag_config(\n            \"removedword\", background=self.base.theme.diffeditor.removedword\n        )\n\n        self.right.tag_config(\"addition\", background=self.base.theme.diffeditor.added)\n        self.right.tag_config(\n            \"removal\",\n            background=self.base.theme.diffeditor.notexist,\n            bgstipple=f\"@{self.stipple}\",\n        )\n        self.right.tag_config(\n            \"addedword\", background=self.base.theme.diffeditor.addedword\n        )\n\n        self.differ = Differ(self)\n\n        if path1 and path2:\n            with open(self.path1, \"r\") as f:\n                self.lhs_data = f.read()\n            with open(self.path2, \"r\") as f:\n                self.rhs_data = f.read()\n\n    def on_scrollbar(self, *args):\n        self.left.yview(*args)\n        self.lhs.on_scroll()\n\n        self.right.yview(*args)\n        self.rhs.on_scroll()\n\n    def on_textscroll(self, *args):\n        self.lhs.scrollbar.set(*args)\n        self.rhs.scrollbar.set(*args)\n        self.on_scrollbar(\"moveto\", args[0])\n\n    def run_show_diff(self):\n        \"\"\"Run the show_diff method in a separate thread.\"\"\"\n\n        threading.Thread(target=self.show_diff).start()\n\n    def show_diff_text(self, lhs, rhs):\n        \"\"\"Show the diff between the two texts.\n\n        Args:\n            lhs (str): The left-hand side text.\n            rhs (str): The right-hand side text.\n        \"\"\"\n\n        self.lhs_data = lhs\n        self.rhs_data = rhs\n\n        self.show_diff()\n\n    def show_diff(self):\n        \"\"\"Show the diff between the two files.\"\"\"\n\n        self.left.set_active(True)\n        self.lhs.clear()\n        self.rhs.clear()\n\n        lhs_lines = [line + \"\\n\" for line in self.lhs_data.split(\"\\n\")]\n        rhs_lines = [line + \"\\n\" for line in self.rhs_data.split(\"\\n\")]\n\n        self.diff = list(self.differ.get_diff(lhs_lines, rhs_lines))\n        for i, line in enumerate(self.diff):\n            marker = line[0]\n            content = line[2:]\n\n            match marker:\n                case \" \":\n                    # line is same in both\n                    self.left.write(content)\n                    self.right.write(content)\n\n                case \"-\":\n                    # line is only on the left\n                    self.left.write(content, \"removal\")\n                    self.left.newline(\"addition\")\n\n                case \"+\":\n                    # line is only on the right\n                    self.right.write(content, \"addition\")\n                    self.left.newline(\"addition\")\n\n                # case \"?\":\n                #     # the above line has changes\n                #     if matches := re.finditer(r'\\++', content):\n                #         self.left.delete(str(float(self.rhs_last_line+1)), str(float(int(float(self.left.index(tk.INSERT))))))\n                #         for match in matches:\n                #             start = f\"{self.rhs_last_line}.{match.start()}\"\n                #             end = f\"{self.rhs_last_line}.{match.end()}\"\n                #             self.right.tag_add(\"addedword\", start, end)\n\n                #     if matches := re.finditer(r'-+', content):\n                #         self.right.delete(str(float(self.lhs_last_line+1)), str(float(int(float(self.right.index(tk.INSERT))))))\n                #         for match in matches:\n                #             start = f\"{self.lhs_last_line}.{match.start()}\"\n                #             end = f\"{self.lhs_last_line}.{match.end()}\"\n                #             self.left.tag_add(\"removedword\", start, end)\n\n            self.left.update()\n            self.right.update()\n\n        self.left.highlighter.highlight()\n        self.right.highlighter.highlight()\n\n        # Add extra empty lines at the bottom if one side has fewer lines\n        lhs_line_count = int(float(self.left.index(tk.END))) - 1\n        rhs_line_count = int(float(self.right.index(tk.END))) - 1\n        if lhs_line_count &gt; rhs_line_count:\n            extra_newlines = lhs_line_count - rhs_line_count\n            for _ in range(extra_newlines):\n                self.right.newline()\n        elif rhs_line_count &gt; lhs_line_count:\n            extra_newlines = rhs_line_count - lhs_line_count\n            for _ in range(extra_newlines):\n                self.left.newline()\n\n        self.left.set_active(False)\n</code></pre>"},{"location":"api-reference/#cupcake.diffeditor.DiffEditor.run_show_diff","title":"<code>run_show_diff()</code>","text":"<p>Run the show_diff method in a separate thread.</p> Source code in <code>cupcake\\diffeditor\\__init__.py</code> <pre><code>def run_show_diff(self):\n    \"\"\"Run the show_diff method in a separate thread.\"\"\"\n\n    threading.Thread(target=self.show_diff).start()\n</code></pre>"},{"location":"api-reference/#cupcake.diffeditor.DiffEditor.show_diff","title":"<code>show_diff()</code>","text":"<p>Show the diff between the two files.</p> Source code in <code>cupcake\\diffeditor\\__init__.py</code> <pre><code>def show_diff(self):\n    \"\"\"Show the diff between the two files.\"\"\"\n\n    self.left.set_active(True)\n    self.lhs.clear()\n    self.rhs.clear()\n\n    lhs_lines = [line + \"\\n\" for line in self.lhs_data.split(\"\\n\")]\n    rhs_lines = [line + \"\\n\" for line in self.rhs_data.split(\"\\n\")]\n\n    self.diff = list(self.differ.get_diff(lhs_lines, rhs_lines))\n    for i, line in enumerate(self.diff):\n        marker = line[0]\n        content = line[2:]\n\n        match marker:\n            case \" \":\n                # line is same in both\n                self.left.write(content)\n                self.right.write(content)\n\n            case \"-\":\n                # line is only on the left\n                self.left.write(content, \"removal\")\n                self.left.newline(\"addition\")\n\n            case \"+\":\n                # line is only on the right\n                self.right.write(content, \"addition\")\n                self.left.newline(\"addition\")\n\n            # case \"?\":\n            #     # the above line has changes\n            #     if matches := re.finditer(r'\\++', content):\n            #         self.left.delete(str(float(self.rhs_last_line+1)), str(float(int(float(self.left.index(tk.INSERT))))))\n            #         for match in matches:\n            #             start = f\"{self.rhs_last_line}.{match.start()}\"\n            #             end = f\"{self.rhs_last_line}.{match.end()}\"\n            #             self.right.tag_add(\"addedword\", start, end)\n\n            #     if matches := re.finditer(r'-+', content):\n            #         self.right.delete(str(float(self.lhs_last_line+1)), str(float(int(float(self.right.index(tk.INSERT))))))\n            #         for match in matches:\n            #             start = f\"{self.lhs_last_line}.{match.start()}\"\n            #             end = f\"{self.lhs_last_line}.{match.end()}\"\n            #             self.left.tag_add(\"removedword\", start, end)\n\n        self.left.update()\n        self.right.update()\n\n    self.left.highlighter.highlight()\n    self.right.highlighter.highlight()\n\n    # Add extra empty lines at the bottom if one side has fewer lines\n    lhs_line_count = int(float(self.left.index(tk.END))) - 1\n    rhs_line_count = int(float(self.right.index(tk.END))) - 1\n    if lhs_line_count &gt; rhs_line_count:\n        extra_newlines = lhs_line_count - rhs_line_count\n        for _ in range(extra_newlines):\n            self.right.newline()\n    elif rhs_line_count &gt; lhs_line_count:\n        extra_newlines = rhs_line_count - lhs_line_count\n        for _ in range(extra_newlines):\n            self.left.newline()\n\n    self.left.set_active(False)\n</code></pre>"},{"location":"api-reference/#cupcake.diffeditor.DiffEditor.show_diff_text","title":"<code>show_diff_text(lhs, rhs)</code>","text":"<p>Show the diff between the two texts.</p> <p>Parameters:</p> Name Type Description Default <code>lhs</code> <code>str</code> <p>The left-hand side text.</p> required <code>rhs</code> <code>str</code> <p>The right-hand side text.</p> required Source code in <code>cupcake\\diffeditor\\__init__.py</code> <pre><code>def show_diff_text(self, lhs, rhs):\n    \"\"\"Show the diff between the two texts.\n\n    Args:\n        lhs (str): The left-hand side text.\n        rhs (str): The right-hand side text.\n    \"\"\"\n\n    self.lhs_data = lhs\n    self.rhs_data = rhs\n\n    self.show_diff()\n</code></pre>"},{"location":"api-reference/#config","title":"Config","text":"<p>Config class.</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <p>Parent widget.</p> required <code>config_file</code> <p>Path to the config file.</p> <code>''</code> <code>darkmode</code> <p>Whether to use dark mode.</p> <code>True</code> <code>font</code> <p>Font to use for the text.</p> <code>''</code> <code>uifont</code> <p>Font to use for the UI.</p> <code>''</code> <p>Attributes:</p> Name Type Description <code>base</code> <p>Parent widget.</p> <code>dir</code> <p>Directory of the module.</p> <code>stipple</code> <p>Path to the stipple file.</p> <code>font</code> <p>Font to use for the text.</p> <code>uifont</code> <p>Font to use for the UI.</p> <code>theme</code> <p>SimpleNamespace object containing the theme settings.</p> <code>syntax</code> <p>Syntax settings.</p> <code>style</code> <p>Style</p> Source code in <code>cupcake\\config\\__init__.py</code> <pre><code>class Config:\n    \"\"\"Config class.\n\n    Args:\n        master: Parent widget.\n        config_file: Path to the config file.\n        darkmode: Whether to use dark mode.\n        font: Font to use for the text.\n        uifont: Font to use for the UI.\n\n    Attributes:\n        base: Parent widget.\n        dir: Directory of the module.\n        stipple: Path to the stipple file.\n        font: Font to use for the text.\n        uifont: Font to use for the UI.\n        theme: SimpleNamespace object containing the theme settings.\n        syntax: Syntax settings.\n        style: Style\n    \"\"\"\n\n    def __init__(self, master, config_file=\"\", darkmode=True, font=\"\", uifont=\"\"):\n        self.base = master\n        self.dir = os.path.dirname(__file__)\n\n        self.stipple = os.path.join(self.dir, \"stipple.xbm\")\n        if not config_file:\n            config_file = (\n                os.path.join(self.dir, \"dark.toml\")\n                if darkmode\n                else os.path.join(self.dir, \"light.toml\")\n            )\n\n        self.font = font or Font(family=\"Consolas\", size=11)\n        self.uifont = uifont or Font(family=\"Segoi UI\", size=10)\n        self.load_from(config_file)\n\n    def load_from(self, config_file: str):\n        self.theme = SimpleNamespace(**toml.load(config_file))\n        self.theme.editor = SimpleNamespace(**self.theme.editor)\n        self.theme.diffeditor = SimpleNamespace(**self.theme.diffeditor)\n        self.syntax = self.theme.syntax\n\n        self.style = Style(self.base, self)\n</code></pre>"},{"location":"api-reference/#languages-enum","title":"Languages Enum","text":"<p>Holds all available languages. To be passed to Editor during initialization.</p> Source code in <code>cupcake\\languages.py</code> <pre><code>class Languages:\n    \"\"\"\n    Holds all available languages. To be passed to Editor during initialization.\n    \"\"\"\n\n    ABAP = \"abap\"\n    AMDGPU = \"amdgpu\"\n    APL = \"apl\"\n    ABNF = \"abnf\"\n    ACTIONSCRIPT3 = \"actionscript3\"\n    ACTIONSCRIPT = \"actionscript\"\n    ADA = \"ada\"\n    ADL = \"adl\"\n    AGDA = \"agda\"\n    AHEUI = \"aheui\"\n    ALLOY = \"alloy\"\n    AMBIENTTALK = \"ambienttalk\"\n    AMPL = \"ampl\"\n    HTML_NG2 = \"html+ng2\"\n    NG2 = \"ng2\"\n    ANTLR_ACTIONSCRIPT = \"antlr-actionscript\"\n    ANTLR_CSHARP = \"antlr-csharp\"\n    ANTLR_CPP = \"antlr-cpp\"\n    ANTLR_JAVA = \"antlr-java\"\n    ANTLR = \"antlr\"\n    ANTLR_OBJC = \"antlr-objc\"\n    ANTLR_PERL = \"antlr-perl\"\n    ANTLR_PYTHON = \"antlr-python\"\n    ANTLR_RUBY = \"antlr-ruby\"\n    APACHECONF = \"apacheconf\"\n    APPLESCRIPT = \"applescript\"\n    ARDUINO = \"arduino\"\n    ARROW = \"arrow\"\n    ARTURO = \"arturo\"\n    ASC = \"asc\"\n    ASPECTJ = \"aspectj\"\n    ASYMPTOTE = \"asymptote\"\n    AUGEAS = \"augeas\"\n    AUTOIT = \"autoit\"\n    AUTOHOTKEY = \"autohotkey\"\n    AWK = \"awk\"\n    BBCBASIC = \"bbcbasic\"\n    BBCODE = \"bbcode\"\n    BC = \"bc\"\n    BST = \"bst\"\n    BARE = \"bare\"\n    BASEMAKE = \"basemake\"\n    BASH = \"bash\"\n    CONSOLE = \"console\"\n    BATCH = \"batch\"\n    BDD = \"bdd\"\n    BEFUNGE = \"befunge\"\n    BERRY = \"berry\"\n    BIBTEX = \"bibtex\"\n    BLITZBASIC = \"blitzbasic\"\n    BLITZMAX = \"blitzmax\"\n    BNF = \"bnf\"\n    BOA = \"boa\"\n    BOO = \"boo\"\n    BOOGIE = \"boogie\"\n    BRAINFUCK = \"brainfuck\"\n    BUGS = \"bugs\"\n    CAMKES = \"camkes\"\n    C = \"c\"\n    CMAKE = \"cmake\"\n    C_OBJDUMP = \"c-objdump\"\n    CPSA = \"cpsa\"\n    CSS_UL4 = \"css+ul4\"\n    ASPX_CS = \"aspx-cs\"\n    CSHARP = \"csharp\"\n    CA65 = \"ca65\"\n    CADL = \"cadl\"\n    CAPDL = \"capdl\"\n    CAPNP = \"capnp\"\n    CBMBAS = \"cbmbas\"\n    CDDL = \"cddl\"\n    CEYLON = \"ceylon\"\n    CFENGINE3 = \"cfengine3\"\n    CHAISCRIPT = \"chaiscript\"\n    CHAPEL = \"chapel\"\n    CHARMCI = \"charmci\"\n    HTML_CHEETAH = \"html+cheetah\"\n    JAVASCRIPT_CHEETAH = \"javascript+cheetah\"\n    CHEETAH = \"cheetah\"\n    XML_CHEETAH = \"xml+cheetah\"\n    CIRRU = \"cirru\"\n    CLAY = \"clay\"\n    CLEAN = \"clean\"\n    CLOJURE = \"clojure\"\n    CLOJURESCRIPT = \"clojurescript\"\n    COBOLFREE = \"cobolfree\"\n    COBOL = \"cobol\"\n    COFFEESCRIPT = \"coffeescript\"\n    CFC = \"cfc\"\n    CFM = \"cfm\"\n    CFS = \"cfs\"\n    COMAL = \"comal\"\n    COMMON_LISP = \"common-lisp\"\n    COMPONENTPASCAL = \"componentpascal\"\n    COQ = \"coq\"\n    CPLINT = \"cplint\"\n    CPP = \"cpp\"\n    CPP_OBJDUMP = \"cpp-objdump\"\n    CRMSH = \"crmsh\"\n    CROC = \"croc\"\n    CRYPTOL = \"cryptol\"\n    CR = \"cr\"\n    CSOUND_DOCUMENT = \"csound-document\"\n    CSOUND = \"csound\"\n    CSOUND_SCORE = \"csound-score\"\n    CSS_DJANGO = \"css+django\"\n    CSS_RUBY = \"css+ruby\"\n    CSS_GENSHITEXT = \"css+genshitext\"\n    CSS = \"css\"\n    CSS_PHP = \"css+php\"\n    CSS_SMARTY = \"css+smarty\"\n    CUDA = \"cuda\"\n    CYPHER = \"cypher\"\n    CYTHON = \"cython\"\n    D = \"d\"\n    D_OBJDUMP = \"d-objdump\"\n    DPATCH = \"dpatch\"\n    DART = \"dart\"\n    DASM16 = \"dasm16\"\n    DEBCONTROL = \"debcontrol\"\n    DELPHI = \"delphi\"\n    DEVICETREE = \"devicetree\"\n    DG = \"dg\"\n    DIFF = \"diff\"\n    DJANGO = \"django\"\n    DOCKER = \"docker\"\n    DTD = \"dtd\"\n    DUEL = \"duel\"\n    DYLAN_CONSOLE = \"dylan-console\"\n    DYLAN = \"dylan\"\n    DYLAN_LID = \"dylan-lid\"\n    ECL = \"ecl\"\n    EC = \"ec\"\n    EARL_GREY = \"earl-grey\"\n    EASYTRIEVE = \"easytrieve\"\n    EBNF = \"ebnf\"\n    EIFFEL = \"eiffel\"\n    IEX = \"iex\"\n    ELIXIR = \"elixir\"\n    ELM = \"elm\"\n    ELPI = \"elpi\"\n    EMACS_LISP = \"emacs-lisp\"\n    EMAIL = \"email\"\n    ERB = \"erb\"\n    ERLANG = \"erlang\"\n    ERL = \"erl\"\n    HTML_EVOQUE = \"html+evoque\"\n    EVOQUE = \"evoque\"\n    XML_EVOQUE = \"xml+evoque\"\n    EXECLINE = \"execline\"\n    EZHIL = \"ezhil\"\n    FSHARP = \"fsharp\"\n    FSTAR = \"fstar\"\n    FACTOR = \"factor\"\n    FANCY = \"fancy\"\n    FAN = \"fan\"\n    FELIX = \"felix\"\n    FENNEL = \"fennel\"\n    FIFT = \"fift\"\n    FISH = \"fish\"\n    FLATLINE = \"flatline\"\n    FLOSCRIPT = \"floscript\"\n    FORTH = \"forth\"\n    FORTRANFIXED = \"fortranfixed\"\n    FORTRAN = \"fortran\"\n    FOXPRO = \"foxpro\"\n    FREEFEM = \"freefem\"\n    FUNC = \"func\"\n    FUTHARK = \"futhark\"\n    GAP_CONSOLE = \"gap-console\"\n    GAP = \"gap\"\n    GDSCRIPT = \"gdscript\"\n    GLSL = \"glsl\"\n    GSQL = \"gsql\"\n    GAS = \"gas\"\n    GCODE = \"gcode\"\n    GENSHI = \"genshi\"\n    GENSHITEXT = \"genshitext\"\n    POT = \"pot\"\n    GHERKIN = \"gherkin\"\n    GNUPLOT = \"gnuplot\"\n    GO = \"go\"\n    GOLO = \"golo\"\n    GOODDATA_CL = \"gooddata-cl\"\n    GOSU = \"gosu\"\n    GST = \"gst\"\n    GRAPHVIZ = \"graphviz\"\n    GROFF = \"groff\"\n    GROOVY = \"groovy\"\n    HLSL = \"hlsl\"\n    HTML_UL4 = \"html+ul4\"\n    HAML = \"haml\"\n    HTML_HANDLEBARS = \"html+handlebars\"\n    HANDLEBARS = \"handlebars\"\n    HASKELL = \"haskell\"\n    HAXE = \"haxe\"\n    HEXDUMP = \"hexdump\"\n    HSAIL = \"hsail\"\n    HSPEC = \"hspec\"\n    HTML_DJANGO = \"html+django\"\n    HTML_GENSHI = \"html+genshi\"\n    HTML = \"html\"\n    HTML_PHP = \"html+php\"\n    HTML_SMARTY = \"html+smarty\"\n    HTTP = \"http\"\n    HAXEML = \"haxeml\"\n    HYLANG = \"hylang\"\n    HYBRIS = \"hybris\"\n    IDL = \"idl\"\n    ICON = \"icon\"\n    IDRIS = \"idris\"\n    IGOR = \"igor\"\n    INFORM6 = \"inform6\"\n    I6T = \"i6t\"\n    INFORM7 = \"inform7\"\n    INI = \"ini\"\n    IO = \"io\"\n    IOKE = \"ioke\"\n    IRC = \"irc\"\n    ISABELLE = \"isabelle\"\n    J = \"j\"\n    JMESPATH = \"jmespath\"\n    JSLT = \"jslt\"\n    JAGS = \"jags\"\n    JASMIN = \"jasmin\"\n    JAVA = \"java\"\n    JAVASCRIPT_DJANGO = \"javascript+django\"\n    JAVASCRIPT_RUBY = \"javascript+ruby\"\n    JS_GENSHITEXT = \"js+genshitext\"\n    JAVASCRIPT = \"javascript\"\n    JAVASCRIPT_PHP = \"javascript+php\"\n    JAVASCRIPT_SMARTY = \"javascript+smarty\"\n    JS_UL4 = \"js+ul4\"\n    JCL = \"jcl\"\n    JSGF = \"jsgf\"\n    JSONLD = \"jsonld\"\n    JSON = \"json\"\n    JSONNET = \"jsonnet\"\n    JSP = \"jsp\"\n    JLCON = \"jlcon\"\n    JULIA = \"julia\"\n    JUTTLE = \"juttle\"\n    K = \"k\"\n    KAL = \"kal\"\n    KCONFIG = \"kconfig\"\n    KMSG = \"kmsg\"\n    KOKA = \"koka\"\n    KOTLIN = \"kotlin\"\n    KUIN = \"kuin\"\n    LSL = \"lsl\"\n    CSS_LASSO = \"css+lasso\"\n    HTML_LASSO = \"html+lasso\"\n    JAVASCRIPT_LASSO = \"javascript+lasso\"\n    LASSO = \"lasso\"\n    XML_LASSO = \"xml+lasso\"\n    LEAN = \"lean\"\n    LESS = \"less\"\n    LIGHTTPD = \"lighttpd\"\n    LILYPOND = \"lilypond\"\n    LIMBO = \"limbo\"\n    LIQUID = \"liquid\"\n    LITERATE_AGDA = \"literate-agda\"\n    LITERATE_CRYPTOL = \"literate-cryptol\"\n    LITERATE_HASKELL = \"literate-haskell\"\n    LITERATE_IDRIS = \"literate-idris\"\n    LIVESCRIPT = \"livescript\"\n    LLVM = \"llvm\"\n    LLVM_MIR_BODY = \"llvm-mir-body\"\n    LLVM_MIR = \"llvm-mir\"\n    LOGOS = \"logos\"\n    LOGTALK = \"logtalk\"\n    LUA = \"lua\"\n    MCFUNCTION = \"mcfunction\"\n    MCSCHEMA = \"mcschema\"\n    MIME = \"mime\"\n    MIPS = \"mips\"\n    MOOCODE = \"moocode\"\n    DOSCON = \"doscon\"\n    MACAULAY2 = \"macaulay2\"\n    MAKE = \"make\"\n    CSS_MAKO = \"css+mako\"\n    HTML_MAKO = \"html+mako\"\n    JAVASCRIPT_MAKO = \"javascript+mako\"\n    MAKO = \"mako\"\n    XML_MAKO = \"xml+mako\"\n    MAQL = \"maql\"\n    MARKDOWN = \"markdown\"\n    MASK = \"mask\"\n    MASON = \"mason\"\n    MATHEMATICA = \"mathematica\"\n    MATLAB = \"matlab\"\n    MATLABSESSION = \"matlabsession\"\n    MAXIMA = \"maxima\"\n    MESON = \"meson\"\n    MINID = \"minid\"\n    MINISCRIPT = \"miniscript\"\n    MODELICA = \"modelica\"\n    MODULA2 = \"modula2\"\n    TRAC_WIKI = \"trac-wiki\"\n    MONKEY = \"monkey\"\n    MONTE = \"monte\"\n    MOONSCRIPT = \"moonscript\"\n    MOSEL = \"mosel\"\n    CSS_MOZPREPROC = \"css+mozpreproc\"\n    MOZHASHPREPROC = \"mozhashpreproc\"\n    JAVASCRIPT_MOZPREPROC = \"javascript+mozpreproc\"\n    MOZPERCENTPREPROC = \"mozpercentpreproc\"\n    XUL_MOZPREPROC = \"xul+mozpreproc\"\n    MQL = \"mql\"\n    MSCGEN = \"mscgen\"\n    MUPAD = \"mupad\"\n    MXML = \"mxml\"\n    MYSQL = \"mysql\"\n    CSS_MYGHTY = \"css+myghty\"\n    HTML_MYGHTY = \"html+myghty\"\n    JAVASCRIPT_MYGHTY = \"javascript+myghty\"\n    MYGHTY = \"myghty\"\n    XML_MYGHTY = \"xml+myghty\"\n    NCL = \"ncl\"\n    NSIS = \"nsis\"\n    NASM = \"nasm\"\n    OBJDUMP_NASM = \"objdump-nasm\"\n    NEMERLE = \"nemerle\"\n    NESC = \"nesc\"\n    NESTEDTEXT = \"nestedtext\"\n    NEWLISP = \"newlisp\"\n    NEWSPEAK = \"newspeak\"\n    NGINX = \"nginx\"\n    NIMROD = \"nimrod\"\n    NIT = \"nit\"\n    NIXOS = \"nixos\"\n    NODEJSREPL = \"nodejsrepl\"\n    NOTMUCH = \"notmuch\"\n    NUSMV = \"nusmv\"\n    NUMPY = \"numpy\"\n    OBJDUMP = \"objdump\"\n    OBJECTIVE_C = \"objective-c\"\n    OBJECTIVE_C__ = \"objective-c++\"\n    OBJECTIVE_J = \"objective-j\"\n    OCAML = \"ocaml\"\n    OCTAVE = \"octave\"\n    ODIN = \"odin\"\n    OMG_IDL = \"omg-idl\"\n    OOC = \"ooc\"\n    OPA = \"opa\"\n    OPENEDGE = \"openedge\"\n    OUTPUT = \"output\"\n    PACMANCONF = \"pacmanconf\"\n    PAN = \"pan\"\n    PARASAIL = \"parasail\"\n    PAWN = \"pawn\"\n    PEG = \"peg\"\n    PERL6 = \"perl6\"\n    PERL = \"perl\"\n    PHIX = \"phix\"\n    PHP = \"php\"\n    PIG = \"pig\"\n    PIKE = \"pike\"\n    PKGCONFIG = \"pkgconfig\"\n    PLPGSQL = \"plpgsql\"\n    POINTLESS = \"pointless\"\n    PONY = \"pony\"\n    PORTUGOL = \"portugol\"\n    POSTSCRIPT = \"postscript\"\n    PSQL = \"psql\"\n    POSTGRESQL = \"postgresql\"\n    POV = \"pov\"\n    POWERSHELL = \"powershell\"\n    PWSH_SESSION = \"pwsh-session\"\n    PRAAT = \"praat\"\n    PROCFILE = \"procfile\"\n    PROLOG = \"prolog\"\n    PROMQL = \"promql\"\n    PROPERTIES = \"properties\"\n    PROTOBUF = \"protobuf\"\n    PSYSH = \"psysh\"\n    PUG = \"pug\"\n    PUPPET = \"puppet\"\n    PYPYLOG = \"pypylog\"\n    PYTHON2 = \"python2\"\n    PY2TB = \"py2tb\"\n    PYCON = \"pycon\"\n    PYTHON = \"python\"\n    PYTB = \"pytb\"\n    PY_UL4 = \"py+ul4\"\n    QBASIC = \"qbasic\"\n    Q = \"q\"\n    QVTO = \"qvto\"\n    QLIK = \"qlik\"\n    QML = \"qml\"\n    RCONSOLE = \"rconsole\"\n    RNG_COMPACT = \"rng-compact\"\n    SPEC = \"spec\"\n    RACKET = \"racket\"\n    RAGEL_C = \"ragel-c\"\n    RAGEL_CPP = \"ragel-cpp\"\n    RAGEL_D = \"ragel-d\"\n    RAGEL_EM = \"ragel-em\"\n    RAGEL_JAVA = \"ragel-java\"\n    RAGEL = \"ragel\"\n    RAGEL_OBJC = \"ragel-objc\"\n    RAGEL_RUBY = \"ragel-ruby\"\n    RD = \"rd\"\n    REASONML = \"reasonml\"\n    REBOL = \"rebol\"\n    RED = \"red\"\n    REDCODE = \"redcode\"\n    REGISTRY = \"registry\"\n    RESOURCEBUNDLE = \"resourcebundle\"\n    REXX = \"rexx\"\n    RHTML = \"rhtml\"\n    RIDE = \"ride\"\n    RITA = \"rita\"\n    ROBOCONF_GRAPH = \"roboconf-graph\"\n    ROBOCONF_INSTANCES = \"roboconf-instances\"\n    ROBOTFRAMEWORK = \"robotframework\"\n    RQL = \"rql\"\n    RSL = \"rsl\"\n    RESTRUCTUREDTEXT = \"restructuredtext\"\n    TRAFFICSCRIPT = \"trafficscript\"\n    RBCON = \"rbcon\"\n    RUBY = \"ruby\"\n    RUST = \"rust\"\n    SAS = \"sas\"\n    SPLUS = \"splus\"\n    SML = \"sml\"\n    SNBT = \"snbt\"\n    SARL = \"sarl\"\n    SASS = \"sass\"\n    SAVI = \"savi\"\n    SCALA = \"scala\"\n    SCAML = \"scaml\"\n    SCDOC = \"scdoc\"\n    SCHEME = \"scheme\"\n    SCILAB = \"scilab\"\n    SCSS = \"scss\"\n    SED = \"sed\"\n    SHEXC = \"shexc\"\n    SHEN = \"shen\"\n    SIEVE = \"sieve\"\n    SILVER = \"silver\"\n    SINGULARITY = \"singularity\"\n    SLASH = \"slash\"\n    SLIM = \"slim\"\n    SLURM = \"slurm\"\n    SMALI = \"smali\"\n    SMALLTALK = \"smalltalk\"\n    SGF = \"sgf\"\n    SMARTY = \"smarty\"\n    SMITHY = \"smithy\"\n    SNOBOL = \"snobol\"\n    SNOWBALL = \"snowball\"\n    SOLIDITY = \"solidity\"\n    SOPHIA = \"sophia\"\n    SP = \"sp\"\n    DEBSOURCES = \"debsources\"\n    SPARQL = \"sparql\"\n    SPICE = \"spice\"\n    SQL_JINJA = \"sql+jinja\"\n    SQL = \"sql\"\n    SQLITE3 = \"sqlite3\"\n    SQUIDCONF = \"squidconf\"\n    SRCINFO = \"srcinfo\"\n    SSP = \"ssp\"\n    STAN = \"stan\"\n    STATA = \"stata\"\n    SUPERCOLLIDER = \"supercollider\"\n    SWIFT = \"swift\"\n    SWIG = \"swig\"\n    SYSTEMVERILOG = \"systemverilog\"\n    TAP = \"tap\"\n    TNT = \"tnt\"\n    TOML = \"toml\"\n    TADS3 = \"tads3\"\n    TAL = \"tal\"\n    TASM = \"tasm\"\n    TCL = \"tcl\"\n    TCSH = \"tcsh\"\n    TCSHCON = \"tcshcon\"\n    TEA = \"tea\"\n    TEAL = \"teal\"\n    TERATERMMACRO = \"teratermmacro\"\n    TERMCAP = \"termcap\"\n    TERMINFO = \"terminfo\"\n    TERRAFORM = \"terraform\"\n    TEX = \"tex\"\n    TEXT = \"text\"\n    TI = \"ti\"\n    THRIFT = \"thrift\"\n    TID = \"tid\"\n    TLB = \"tlb\"\n    TODOTXT = \"todotxt\"\n    TSQL = \"tsql\"\n    TREETOP = \"treetop\"\n    TURTLE = \"turtle\"\n    HTML_TWIG = \"html+twig\"\n    TWIG = \"twig\"\n    TYPESCRIPT = \"typescript\"\n    TYPOSCRIPTCSSDATA = \"typoscriptcssdata\"\n    TYPOSCRIPTHTMLDATA = \"typoscripthtmldata\"\n    TYPOSCRIPT = \"typoscript\"\n    UL4 = \"ul4\"\n    UCODE = \"ucode\"\n    UNICON = \"unicon\"\n    UNIXCONFIG = \"unixconfig\"\n    URBISCRIPT = \"urbiscript\"\n    USD = \"usd\"\n    VBSCRIPT = \"vbscript\"\n    VCL = \"vcl\"\n    VCLSNIPPETS = \"vclsnippets\"\n    VCTREESTATUS = \"vctreestatus\"\n    VGL = \"vgl\"\n    VALA = \"vala\"\n    ASPX_VB = \"aspx-vb\"\n    VB_NET = \"vb.net\"\n    HTML_VELOCITY = \"html+velocity\"\n    VELOCITY = \"velocity\"\n    XML_VELOCITY = \"xml+velocity\"\n    VERILOG = \"verilog\"\n    VHDL = \"vhdl\"\n    VIM = \"vim\"\n    WDIFF = \"wdiff\"\n    WAST = \"wast\"\n    WEBIDL = \"webidl\"\n    WHILEY = \"whiley\"\n    WOWTOC = \"wowtoc\"\n    WREN = \"wren\"\n    X10 = \"x10\"\n    XML_UL4 = \"xml+ul4\"\n    XQUERY = \"xquery\"\n    XML_DJANGO = \"xml+django\"\n    XML_RUBY = \"xml+ruby\"\n    XML = \"xml\"\n    XML_PHP = \"xml+php\"\n    XML_SMARTY = \"xml+smarty\"\n    XORG_CONF = \"xorg.conf\"\n    XSLT = \"xslt\"\n    XTEND = \"xtend\"\n    EXTEMPORE = \"extempore\"\n    YAML_JINJA = \"yaml+jinja\"\n    YAML = \"yaml\"\n    YANG = \"yang\"\n    ZEEK = \"zeek\"\n    ZEPHIR = \"zephir\"\n    ZIG = \"zig\"\n    ANSYS = \"ansys\"\n    IPYTHON2 = \"ipython2\"\n    IPYTHON3 = \"ipython3\"\n    IPYTHONCONSOLE = \"ipythonconsole\"\n</code></pre>"},{"location":"api-reference/#image-viewer","title":"Image Viewer","text":"<p>               Bases: <code>BaseEditor</code></p> <p>ImageViewer class.</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <p>Parent widget.</p> required <code>path</code> <code>str</code> <p>Path to the image file.</p> required Source code in <code>cupcake\\imageviewer\\__init__.py</code> <pre><code>class ImageViewer(BaseEditor):\n    \"\"\"ImageViewer class.\n\n    Args:\n        master: Parent widget.\n        path: Path to the image file.\n    \"\"\"\n\n    def __init__(self, master, path: str, *args, **kwargs):\n        super().__init__(master, path, editable=False, *args, **kwargs)\n        self.open_image()\n\n    def open_image(self):\n        \"\"\"Opens the image file.\"\"\"\n        self.image = Image.open(self.path)\n        self.image.thumbnail((700, 700))\n        self.tk_image = ImageTk.PhotoImage(self.image)\n\n        self.image_label = tk.Label(\n            self, image=self.tk_image, bg=self.base.theme.background\n        )\n        self.image_label.pack(fill=tk.BOTH, expand=True)\n</code></pre>"},{"location":"api-reference/#cupcake.imageviewer.ImageViewer.open_image","title":"<code>open_image()</code>","text":"<p>Opens the image file.</p> Source code in <code>cupcake\\imageviewer\\__init__.py</code> <pre><code>def open_image(self):\n    \"\"\"Opens the image file.\"\"\"\n    self.image = Image.open(self.path)\n    self.image.thumbnail((700, 700))\n    self.tk_image = ImageTk.PhotoImage(self.image)\n\n    self.image_label = tk.Label(\n        self, image=self.tk_image, bg=self.base.theme.background\n    )\n    self.image_label.pack(fill=tk.BOTH, expand=True)\n</code></pre>"},{"location":"api-reference/#text-editor","title":"Text Editor","text":"<p>               Bases: <code>BaseEditor</code></p> <p>TextEditor class.</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <p>Parent widget.</p> required <code>path</code> <p>Path to the file.</p> <code>''</code> <code>language</code> <p>Language to use for syntax highlighting.</p> <code>''</code> <code>font</code> <p>Font to use for the text.</p> <code>''</code> <code>minimalist</code> <p>Whether to use the minimalist mode.</p> <code>False</code> Source code in <code>cupcake\\texteditor\\__init__.py</code> <pre><code>class TextEditor(BaseEditor):\n    \"\"\"TextEditor class.\n\n    Args:\n        master: Parent widget.\n        path: Path to the file.\n        language: Language to use for syntax highlighting.\n        font: Font to use for the text.\n        minimalist: Whether to use the minimalist mode.\n    \"\"\"\n\n    def __init__(\n        self, master, path=\"\", language=\"\", font=\"\", minimalist=False, *args, **kwargs\n    ):\n        super().__init__(master, path, *args, **kwargs)\n        self.font = font or self.base.settings.font\n        self.minimalist = minimalist\n        self.language = language\n\n        self.rowconfigure(0, weight=1)\n        self.columnconfigure(1, weight=1)\n\n        self.text = Text(self, path=self.path, minimalist=minimalist, language=language)\n        self.linenumbers = LineNumbers(self, self.text, self.font)\n        self.scrollbar = Scrollbar(\n            self, orient=tk.VERTICAL, command=self.text.yview, style=\"EditorScrollbar\"\n        )\n\n        self.text.config(font=self.font)\n        self.text.configure(yscrollcommand=self.scrollbar.set)\n\n        if not self.minimalist:\n            self.minimap = Minimap(self, self.text)\n            self.minimap.grid(row=0, column=2, sticky=tk.NS)\n\n        self.linenumbers.grid(row=0, column=0, sticky=tk.NS)\n        self.text.grid(row=0, column=1, sticky=tk.NSEW)\n        self.scrollbar.grid(row=0, column=3, sticky=tk.NS)\n\n        self.text.bind(\"&lt;&lt;Change&gt;&gt;\", self.on_change)\n        self.text.bind(\"&lt;&lt;Scroll&gt;&gt;\", self.on_scroll)\n\n        if self.path and os.path.isfile(self.path):\n            self.text.load_file()\n\n    def on_change(self, *_):\n        self.text.refresh()\n        self.linenumbers.redraw()\n        # self.minimap.redraw()\n\n    def on_scroll(self, *_):\n        self.linenumbers.redraw()\n\n    def unsupported_file(self):\n        self.text.highlighter.lexer = None\n        self.text.show_unsupported_dialog()\n        self.linenumbers.grid_remove()\n        self.scrollbar.grid_remove()\n        self.editable = False\n\n    def focus(self):\n        self.text.focus()\n        self.on_change()\n\n    def set_fontsize(self, size):\n        self.font.configure(size=size)\n        self.linenumbers.set_bar_width(size * 3)\n        self.on_change()\n\n    def save(self, path=None):\n        if self.editable:\n            self.text.save_file(path)\n\n    def cut(self, *_):\n        if self.editable:\n            self.text.cut()\n\n    def copy(self, *_):\n        if self.editable:\n            self.text.copy()\n\n    def paste(self, *_):\n        if self.editable:\n            self.text.paste()\n\n    def write(self, *args, **kwargs):\n        if self.editable:\n            self.text.write(*args, **kwargs)\n\n    def insert(self, *args, **kwargs):\n        if self.editable:\n            self.text.insert(*args, **kwargs)\n\n    def get(self, *args, **kwargs):\n        if self.editable:\n            self.text.get(*args, **kwargs)\n\n    def clear(self):\n        self.delete(\"1.0\", tk.END)\n\n    def delete(self, *args, **kwargs):\n        if self.editable:\n            self.text.delete(*args, **kwargs)\n\n    def mark_set(self, *args, **kwargs):\n        if self.editable:\n            self.text.mark_set(*args, **kwargs)\n\n    def compare(self, *args, **kwargs):\n        return self.text.compare(*args, **kwargs)\n\n    def dlineinfo(self, index):\n        return self.text.dlineinfo(index)\n\n    def edit_modified(self, arg=None):\n        return self.text.edit_modified(arg)\n\n    def edit_redo(self):\n        if self.editable:\n            self.text.edit_redo()\n\n    def edit_reset(self):\n        if self.editable:\n            self.text.edit_reset()\n\n    def edit_separator(self):\n        if self.editable:\n            self.text.edit_separator()\n\n    def edit_undo(self):\n        if self.editable:\n            self.text.edit_undo()\n\n    def image_create(self, index, **kwargs):\n        if self.editable:\n            return self.text.image_create(index, **kwargs)\n\n    def image_cget(self, index, option):\n        return self.text.image_cget(index, option)\n\n    def image_configure(self, index, **kwargs):\n        if self.editable:\n            return self.text.image_configure(index, **kwargs)\n\n    def image_names(self):\n        return self.text.image_names()\n\n    def index(self, i):\n        return self.text.index(i)\n\n    def mark_gravity(self, mark, gravity=None):\n        return self.text.mark_gravity(mark, gravity)\n\n    def mark_names(self):\n        return self.text.mark_names()\n\n    def mark_next(self, index):\n        return self.text.mark_next(index)\n\n    def mark_previous(self, index):\n        return self.text.mark_previous(index)\n\n    def mark_set(self, mark, index):\n        if self.editable:\n            self.text.mark_set(mark, index)\n\n    def mark_unset(self, mark):\n        if self.editable:\n            self.text.mark_unset(mark)\n\n    def scan_dragto(self, x, y):\n        self.text.scan_dragto(x, y)\n\n    def scan_mark(self, x, y):\n        self.text.scan_mark(x, y)\n\n    def search(self, pattern, index, **kwargs):\n        return self.text.search(pattern, index, **kwargs)\n\n    def see(self, index):\n        self.text.see(index)\n\n    def tag_add(self, tagName, index1, index2=None):\n        if self.editable:\n            self.text.tag_add(tagName, index1, index2)\n\n    def tag_bind(self, tagName, sequence, func, add=None):\n        self.text.tag_bind(tagName, sequence, func, add)\n\n    def tag_cget(self, tagName, option):\n        return self.text.tag_cget(tagName, option)\n\n    def tag_config(self, tagName, **kwargs):\n        if self.editable:\n            self.text.tag_config(tagName, **kwargs)\n\n    def tag_names(self, index=None):\n        return self.text.tag_names(index)\n\n    def tag_nextrange(self, tagName, index1, index2=None):\n        return self.text.tag_nextrange(tagName, index1, index2)\n\n    def tag_prevrange(self, tagName, index1, index2=None):\n        return self.text.tag_prevrange(tagName, index1, index2)\n\n    def tag_raise(self, tagName, aboveThis=None):\n        if self.editable:\n            self.text.tag_raise(tagName, aboveThis)\n\n    def tag_ranges(self, tagName):\n        return self.text.tag_ranges(tagName)\n\n    def tag_remove(self, tagName, index1, index2=None):\n        if self.editable:\n            self.text.tag_remove(tagName, index1, index2)\n\n    def tag_unbind(self, tagName, sequence, funcid=None):\n        self.text.tag_unbind(tagName, sequence, funcid)\n\n    def window_cget(self, index, option):\n        return self.text.window_cget(index, option)\n\n    def window_configure(self, index, **kwargs):\n        if self.editable:\n            self.text.window_configure(index, **kwargs)\n\n    def window_create(self, index, **kwargs):\n        if self.editable:\n            self.text.window_create(index, **kwargs)\n\n    def window_names(self):\n        return self.text.window_names()\n\n    def xview_moveto(self, fraction):\n        self.text.xview_moveto(fraction)\n\n    def xview_scroll(self, n, what):\n        self.text.xview_scroll(n, what)\n\n    def yview_moveto(self, fraction):\n        self.text.yview_moveto(fraction)\n\n    def yview_scroll(self, n, what):\n        self.text.yview_scroll(n, what)\n</code></pre>"},{"location":"api-reference/#breadcrumbs","title":"Breadcrumbs","text":"<p>               Bases: <code>Frame</code></p> <p>BreadCrumbs class.</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <p>Parent widget.</p> required <code>path</code> <p>Path to the file.</p> <code>''</code> <p>Attributes:</p> Name Type Description <code>pathview</code> <p>PathView object.</p> Source code in <code>cupcake\\breadcrumbs\\__init__.py</code> <pre><code>class BreadCrumbs(Frame):\n    \"\"\"BreadCrumbs class.\n\n    Args:\n        master: Parent widget.\n        path: Path to the file.\n\n    Attributes:\n        pathview: PathView object.\n    \"\"\"\n\n    def __init__(self, master, path=\"\", *args, **kwargs):\n        super().__init__(master, *args, **kwargs)\n        self.config(padx=20, bg=self.base.theme.breadcrumbs[\"background\"])\n\n        self.pathview = PathView(self)\n        path = os.path.abspath(path).split(\"\\\\\")\n        for i, item in enumerate(path):\n            text = item if item == path[-1] else f\"{item} \u203a\"\n            self.additem(\"\\\\\".join(path[:i]), text)\n\n    def additem(self, path: str, text: str):\n        \"\"\"Adds an item to the breadcrumbs.\n\n        Args:\n            path: Path to the item.\n            text: Text to display.\n        \"\"\"\n\n        btn = Item(self, path, text=text)\n        btn.bind(\"&lt;Button-1&gt;\", self.pathview.show)\n        btn.pack(side=tk.LEFT)\n</code></pre>"},{"location":"api-reference/#cupcake.breadcrumbs.BreadCrumbs.additem","title":"<code>additem(path, text)</code>","text":"<p>Adds an item to the breadcrumbs.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the item.</p> required <code>text</code> <code>str</code> <p>Text to display.</p> required Source code in <code>cupcake\\breadcrumbs\\__init__.py</code> <pre><code>def additem(self, path: str, text: str):\n    \"\"\"Adds an item to the breadcrumbs.\n\n    Args:\n        path: Path to the item.\n        text: Text to display.\n    \"\"\"\n\n    btn = Item(self, path, text=text)\n    btn.bind(\"&lt;Button-1&gt;\", self.pathview.show)\n    btn.pack(side=tk.LEFT)\n</code></pre>"},{"location":"api-reference/#path-view","title":"Path View","text":"<p>               Bases: <code>Toplevel</code></p> <p>PathView class.</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <p>Parent widget.</p> required <code>width</code> <p>Width of the path view.</p> <code>150</code> Source code in <code>cupcake\\breadcrumbs\\pathview.py</code> <pre><code>class PathView(Toplevel):\n    \"\"\"PathView class.\n\n    Args:\n        master: Parent widget.\n        width: Width of the path view.\n    \"\"\"\n\n    def __init__(self, master, width=150, *args, **kwargs):\n        super().__init__(master, *args, **kwargs)\n        self.width = round(width)\n\n        self.tree = DirectoryTree(self, width=width)\n        self.tree.pack()\n\n        self.config(pady=1, padx=1, bg=self.base.theme.border)\n        self.overrideredirect(True)\n        self.withdraw()\n\n        self.grid_columnconfigure(0, weight=1)\n        self.grid_rowconfigure(0, weight=1)\n        self.configure_bindings()\n\n    def configure_bindings(self):\n        self.bind(\"&lt;FocusOut&gt;\", self.hide)\n        self.bind(\"&lt;Escape&gt;\", self.hide)\n\n    def get_popup_x(self, width):\n        \"\"\"Returns the x position for the popup.\n\n        Args:\n            width: Width of the popup.\n\n        Returns:\n            int: X position.\n        \"\"\"\n\n        return self.winfo_rootx() + int(self.winfo_width() / 2) - int(width / 2)\n\n    def get_popup_y(self):\n        \"\"\"Returns the y position for the popup.\n\n        Returns:\n            int: Y position.\n        \"\"\"\n\n        return self.winfo_rooty()\n\n    def hide(self, *_):\n        \"\"\"Hides the path view.\"\"\"\n\n        self.withdraw()\n\n    def show(self, e: tk.Event):\n        \"\"\"Shows the path view.\n\n        Args:\n            e: Event object.\n        \"\"\"\n\n        self.update_idletasks()\n        w = e.widget\n        x = w.winfo_rootx()\n        y = w.winfo_rooty() + w.winfo_height()\n\n        if not w.path:\n            return\n        self.tree.change_path(w.path)\n\n        self.geometry(f\"+{x}+{y}\")\n        self.deiconify()\n        self.focus_set()\n</code></pre>"},{"location":"api-reference/#cupcake.breadcrumbs.PathView.get_popup_x","title":"<code>get_popup_x(width)</code>","text":"<p>Returns the x position for the popup.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <p>Width of the popup.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>X position.</p> Source code in <code>cupcake\\breadcrumbs\\pathview.py</code> <pre><code>def get_popup_x(self, width):\n    \"\"\"Returns the x position for the popup.\n\n    Args:\n        width: Width of the popup.\n\n    Returns:\n        int: X position.\n    \"\"\"\n\n    return self.winfo_rootx() + int(self.winfo_width() / 2) - int(width / 2)\n</code></pre>"},{"location":"api-reference/#cupcake.breadcrumbs.PathView.get_popup_y","title":"<code>get_popup_y()</code>","text":"<p>Returns the y position for the popup.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Y position.</p> Source code in <code>cupcake\\breadcrumbs\\pathview.py</code> <pre><code>def get_popup_y(self):\n    \"\"\"Returns the y position for the popup.\n\n    Returns:\n        int: Y position.\n    \"\"\"\n\n    return self.winfo_rooty()\n</code></pre>"},{"location":"api-reference/#cupcake.breadcrumbs.PathView.hide","title":"<code>hide(*_)</code>","text":"<p>Hides the path view.</p> Source code in <code>cupcake\\breadcrumbs\\pathview.py</code> <pre><code>def hide(self, *_):\n    \"\"\"Hides the path view.\"\"\"\n\n    self.withdraw()\n</code></pre>"},{"location":"api-reference/#cupcake.breadcrumbs.PathView.show","title":"<code>show(e)</code>","text":"<p>Shows the path view.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Event</code> <p>Event object.</p> required Source code in <code>cupcake\\breadcrumbs\\pathview.py</code> <pre><code>def show(self, e: tk.Event):\n    \"\"\"Shows the path view.\n\n    Args:\n        e: Event object.\n    \"\"\"\n\n    self.update_idletasks()\n    w = e.widget\n    x = w.winfo_rootx()\n    y = w.winfo_rooty() + w.winfo_height()\n\n    if not w.path:\n        return\n    self.tree.change_path(w.path)\n\n    self.geometry(f\"+{x}+{y}\")\n    self.deiconify()\n    self.focus_set()\n</code></pre>"},{"location":"api-reference/#line-numbers","title":"Line Numbers","text":"<p>               Bases: <code>Canvas</code></p> Source code in <code>cupcake\\texteditor\\linenumbers\\__init__.py</code> <pre><code>class LineNumbers(Canvas):\n    def __init__(self, master, text=None, font=None, *args, **kwargs):\n        super().__init__(master, *args, **kwargs)\n        self.font = font\n\n        self.fg = self.base.theme.linenumbers[\"foreground\"]\n        self.hfg = self.base.theme.linenumbers[\"activeforeground\"]\n\n        self.config(width=65, bd=0, highlightthickness=0, bg=self.base.theme.linenumbers[\"background\"])\n        self.text = text\n\n    def attach(self, text):\n        self.text = text\n\n    def mark_line(self, line):\n        dline = self.text.dlineinfo(line)\n\n        if not dline:\n            return\n\n        y = dline[1]\n        btn = Menubutton(self, \n            text=\"&gt;\", font=self.font, cursor=\"hand2\", borderwidth=0,\n            width=2, height=1, pady=0, padx=0, relief=tk.FLAT, **self.base.theme.linenumbers)\n        self.create_window(70, y-2, anchor=tk.NE, window=btn)\n\n    def set_bar_width(self, width):\n        self.configure(width=width)\n\n    def get_indentation_level(self, line):\n        \"\"\"Get the indentation level of a given line.\"\"\"\n        return len(line) - len(line.lstrip())\n\n    def redraw(self, *_):\n        self.delete(tk.ALL)\n\n        prev_indent = 0\n        i = self.text.index(\"@0,0\")\n        while True:\n            dline = self.text.dlineinfo(i)\n            if dline is None:\n                break\n\n            y = dline[1]\n            linenum = str(i).split(\".\")[0]\n\n            # Get the text content of the current line\n            line_content = self.text.get(f\"{linenum}.0\", f\"{linenum}.end\")\n            current_indent = self.get_indentation_level(line_content)\n\n            # to highlight the current line\n            curline = self.text.dlineinfo(tk.INSERT)\n            cur_y = curline[1] if curline else None\n\n            if not cur_y:\n                i = self.text.index(f\"{i}+1line\")\n                continue\n\n            self.create_text(40, y, anchor=tk.NE, text=linenum, font=self.font, tag=i, fill=self.hfg if y == cur_y else self.fg)\n            self.tag_bind(i, \"&lt;Button-1&gt;\", lambda _, i=i: self.text.select_line(i))\n\n            if current_indent &gt; prev_indent:\n                self.create_text(50, y, anchor=tk.NW, text=\"+\", font=self.font, fill=self.fg, tag=f\"f{i}\")\n                self.tag_bind(f\"f{i}\", \"&lt;Button-1&gt;\", lambda _, i=i: print(f\"Fold from {i}\"))\n\n            # Update the previous indentation level\n            prev_indent = current_indent\n            i = self.text.index(f\"{i}+1line\")\n\n    def draw_breakpoint(self, y):\n        bp = Breakpoint(self)\n        self.create_window(21, y-2, anchor=tk.NE, window=bp)\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.linenumbers.LineNumbers.get_indentation_level","title":"<code>get_indentation_level(line)</code>","text":"<p>Get the indentation level of a given line.</p> Source code in <code>cupcake\\texteditor\\linenumbers\\__init__.py</code> <pre><code>def get_indentation_level(self, line):\n    \"\"\"Get the indentation level of a given line.\"\"\"\n    return len(line) - len(line.lstrip())\n</code></pre>"},{"location":"api-reference/#auto-complete","title":"Auto Complete","text":"<p>               Bases: <code>Toplevel</code></p> <p>AutoComplete class.</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <p>Parent widget.</p> required <code>items</code> <p>List of items to autocomplete.</p> <code>None</code> <code>active</code> <p>Whether the autocomplete is active.</p> <code>False</code> Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>class AutoComplete(Toplevel):\n    \"\"\"AutoComplete class.\n\n    Args:\n        master: Parent widget.\n        items: List of items to autocomplete.\n        active: Whether the autocomplete is active.\n    \"\"\"\n\n    def __init__(self, master, items=None, active=False, *args, **kwargs):\n        super().__init__(master, *args, **kwargs)\n        self.autocomplete_kinds = Kinds(self)\n        self.config(padx=1, pady=1, bg=self.base.theme.border)\n\n        self.active = active\n        if not self.active:\n            self.withdraw()\n\n        self.overrideredirect(True)\n        self.wm_attributes(\"-topmost\", True)\n        self.grid_columnconfigure(0, weight=1)\n\n        self.menu_items = []\n        self.active_items = []\n        self.row = 0\n        self.selected = 0\n        if items:\n            # TODO this should be a dict\n            self.items = items  # [(completion, type), ...]\n            self.add_all_items()\n            self.refresh_selected()\n\n    def update_completions(self):\n        \"\"\"Updates and rerenders the completions.\"\"\"\n\n        self.refresh_geometry()\n        self.update_idletasks()\n        self.update_all_words()\n\n        term = self.master.get_current_word()\n\n        exact, starts, includes = [], [], []\n        for i in self.menu_items:\n            if i.get_text() == term:\n                exact.append(i)\n            elif i.get_text().startswith(term):\n                starts.append(i)\n            elif term in i.get_text():\n                includes.append(i)\n        new = list(chain(exact, starts, includes))\n\n        self.hide_all_items()\n        if any(new):\n            self.show_items(new[:10] if len(new) &gt; 10 else new, term)\n        else:\n            self.hide()\n\n    def move_up(self, *_):\n        \"\"\"Moves the selection up.\"\"\"\n        if self.active:\n            self.select(-1)\n            return \"break\"\n\n    def move_down(self, *_):\n        \"\"\"Moves the selection down.\"\"\"\n        if self.active:\n            self.select(1)\n            return \"break\"\n\n    def add_all_items(self):\n        \"\"\"Adds all items to the menu.\"\"\"\n        for i in self.items:\n            self.add_item(i[0], i[1] if len(i) &gt; 1 else None)\n\n        self.active_items = self.menu_items\n        self.refresh_selected()\n\n    def update_all_words(self):\n        \"\"\"Updates the words in the menu.\"\"\"\n        for word in self.master.words:\n            if word not in self.get_items_text():\n                self.add_item(word, \"word\")\n\n        for word in self.menu_items:\n            if word.get_text() not in self.master.words and word.get_kind() == \"word\":\n                self.remove_item(word)\n\n    def add_item(self, text: str, kind=\"\"):\n        \"\"\"Adds an item to the menu.\n\n        Args:\n            text: Text to add.\n            kind: Kind of the item.\n        \"\"\"\n\n        new_item = AutoCompleteItem(self, text, kind=kind)\n        new_item.grid(row=self.row, sticky=tk.EW)\n\n        self.menu_items.append(new_item)\n\n        self.row += 1\n\n    def remove_item(self, item: AutoCompleteItem):\n        \"\"\"Removes an item from the menu.\n\n        Args:\n            item: Item to remove.\n        \"\"\"\n\n        a = self.menu_items\n        item.grid_forget()\n        self.menu_items.remove(item)\n        self.row -= 1\n\n    def select(self, delta: int):\n        \"\"\"Selects an item.\n\n        Args:\n            delta: The change in selection.\n        \"\"\"\n\n        self.selected += delta\n        if self.selected &gt; len(self.active_items) - 1:\n            self.selected = 0\n        elif self.selected &lt; 0:\n            self.selected = len(self.active_items) - 1\n        self.refresh_selected()\n\n    def reset_selection(self):\n        \"\"\"Resets the selection.\"\"\"\n\n        self.selected = 0\n        self.refresh_selected()\n\n    def refresh_selected(self):\n        \"\"\"Refreshes the selected item.\"\"\"\n\n        for i in self.active_items:\n            i.deselect()\n        if self.selected &lt; len(self.active_items):\n            self.active_items[self.selected].select()\n\n    def get_items_text(self):\n        \"\"\"Gets the text of all items.\n\n        Returns:\n            List of text of all items.\n        \"\"\"\n\n        return [i.get_text() for i in self.menu_items]\n\n    def hide_all_items(self):\n        \"\"\"Hides all items.\"\"\"\n\n        for i in self.menu_items:\n            i.grid_forget()\n\n        self.active_items = []\n        self.row = 1\n\n    def show_items(self, items: list[AutoCompleteItem], term: str):\n        \"\"\"Shows the items.\n\n        Args:\n            items: Items to show.\n            term: The term to match.\n        \"\"\"\n\n        self.active_items = items\n        for i in items:\n            i.grid(row=self.row, sticky=tk.EW)\n            self.row += 1\n\n            i.mark_term(term)\n\n        self.reset_selection()\n\n    def refresh_geometry(self, *_):\n        \"\"\"Refreshes the geometry of the menu.\"\"\"\n\n        self.update_idletasks()\n        self.geometry(\"+{}+{}\".format(*self.master.cursor_screen_location()))\n\n    def show(self, pos: tuple[int, int]):\n        \"\"\"Shows the menu.\n\n        Args:\n            pos: Position to show the menu.\n        \"\"\"\n\n        self.active = True\n        self.update_idletasks()\n        self.geometry(\"+{}+{}\".format(*pos))\n        self.deiconify()\n\n    def hide(self, *_):\n        \"\"\"Hides the menu.\"\"\"\n\n        self.active = False\n        self.withdraw()\n        self.reset()\n\n    def reset(self):\n        \"\"\"Resets the menu.\"\"\"\n\n        self.reset_selection()\n\n    def choose(self, this=None, *_):\n        \"\"\"Chooses an item.\n\n        Args:\n            this: The item to choose. Used when user clicks on an item.\n        \"\"\"\n\n        if not self.active_items:\n            return\n\n        if not this:\n            this = self.active_items[self.selected]\n\n        self.master.confirm_autocomplete(this.get_text())\n        self.hide()\n        return \"break\"\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.add_all_items","title":"<code>add_all_items()</code>","text":"<p>Adds all items to the menu.</p> Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def add_all_items(self):\n    \"\"\"Adds all items to the menu.\"\"\"\n    for i in self.items:\n        self.add_item(i[0], i[1] if len(i) &gt; 1 else None)\n\n    self.active_items = self.menu_items\n    self.refresh_selected()\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.add_item","title":"<code>add_item(text, kind='')</code>","text":"<p>Adds an item to the menu.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to add.</p> required <code>kind</code> <p>Kind of the item.</p> <code>''</code> Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def add_item(self, text: str, kind=\"\"):\n    \"\"\"Adds an item to the menu.\n\n    Args:\n        text: Text to add.\n        kind: Kind of the item.\n    \"\"\"\n\n    new_item = AutoCompleteItem(self, text, kind=kind)\n    new_item.grid(row=self.row, sticky=tk.EW)\n\n    self.menu_items.append(new_item)\n\n    self.row += 1\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.choose","title":"<code>choose(this=None, *_)</code>","text":"<p>Chooses an item.</p> <p>Parameters:</p> Name Type Description Default <code>this</code> <p>The item to choose. Used when user clicks on an item.</p> <code>None</code> Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def choose(self, this=None, *_):\n    \"\"\"Chooses an item.\n\n    Args:\n        this: The item to choose. Used when user clicks on an item.\n    \"\"\"\n\n    if not self.active_items:\n        return\n\n    if not this:\n        this = self.active_items[self.selected]\n\n    self.master.confirm_autocomplete(this.get_text())\n    self.hide()\n    return \"break\"\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.get_items_text","title":"<code>get_items_text()</code>","text":"<p>Gets the text of all items.</p> <p>Returns:</p> Type Description <p>List of text of all items.</p> Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def get_items_text(self):\n    \"\"\"Gets the text of all items.\n\n    Returns:\n        List of text of all items.\n    \"\"\"\n\n    return [i.get_text() for i in self.menu_items]\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.hide","title":"<code>hide(*_)</code>","text":"<p>Hides the menu.</p> Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def hide(self, *_):\n    \"\"\"Hides the menu.\"\"\"\n\n    self.active = False\n    self.withdraw()\n    self.reset()\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.hide_all_items","title":"<code>hide_all_items()</code>","text":"<p>Hides all items.</p> Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def hide_all_items(self):\n    \"\"\"Hides all items.\"\"\"\n\n    for i in self.menu_items:\n        i.grid_forget()\n\n    self.active_items = []\n    self.row = 1\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.move_down","title":"<code>move_down(*_)</code>","text":"<p>Moves the selection down.</p> Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def move_down(self, *_):\n    \"\"\"Moves the selection down.\"\"\"\n    if self.active:\n        self.select(1)\n        return \"break\"\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.move_up","title":"<code>move_up(*_)</code>","text":"<p>Moves the selection up.</p> Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def move_up(self, *_):\n    \"\"\"Moves the selection up.\"\"\"\n    if self.active:\n        self.select(-1)\n        return \"break\"\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.refresh_geometry","title":"<code>refresh_geometry(*_)</code>","text":"<p>Refreshes the geometry of the menu.</p> Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def refresh_geometry(self, *_):\n    \"\"\"Refreshes the geometry of the menu.\"\"\"\n\n    self.update_idletasks()\n    self.geometry(\"+{}+{}\".format(*self.master.cursor_screen_location()))\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.refresh_selected","title":"<code>refresh_selected()</code>","text":"<p>Refreshes the selected item.</p> Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def refresh_selected(self):\n    \"\"\"Refreshes the selected item.\"\"\"\n\n    for i in self.active_items:\n        i.deselect()\n    if self.selected &lt; len(self.active_items):\n        self.active_items[self.selected].select()\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.remove_item","title":"<code>remove_item(item)</code>","text":"<p>Removes an item from the menu.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>AutoCompleteItem</code> <p>Item to remove.</p> required Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def remove_item(self, item: AutoCompleteItem):\n    \"\"\"Removes an item from the menu.\n\n    Args:\n        item: Item to remove.\n    \"\"\"\n\n    a = self.menu_items\n    item.grid_forget()\n    self.menu_items.remove(item)\n    self.row -= 1\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.reset","title":"<code>reset()</code>","text":"<p>Resets the menu.</p> Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def reset(self):\n    \"\"\"Resets the menu.\"\"\"\n\n    self.reset_selection()\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.reset_selection","title":"<code>reset_selection()</code>","text":"<p>Resets the selection.</p> Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def reset_selection(self):\n    \"\"\"Resets the selection.\"\"\"\n\n    self.selected = 0\n    self.refresh_selected()\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.select","title":"<code>select(delta)</code>","text":"<p>Selects an item.</p> <p>Parameters:</p> Name Type Description Default <code>delta</code> <code>int</code> <p>The change in selection.</p> required Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def select(self, delta: int):\n    \"\"\"Selects an item.\n\n    Args:\n        delta: The change in selection.\n    \"\"\"\n\n    self.selected += delta\n    if self.selected &gt; len(self.active_items) - 1:\n        self.selected = 0\n    elif self.selected &lt; 0:\n        self.selected = len(self.active_items) - 1\n    self.refresh_selected()\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.show","title":"<code>show(pos)</code>","text":"<p>Shows the menu.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>tuple[int, int]</code> <p>Position to show the menu.</p> required Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def show(self, pos: tuple[int, int]):\n    \"\"\"Shows the menu.\n\n    Args:\n        pos: Position to show the menu.\n    \"\"\"\n\n    self.active = True\n    self.update_idletasks()\n    self.geometry(\"+{}+{}\".format(*pos))\n    self.deiconify()\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.show_items","title":"<code>show_items(items, term)</code>","text":"<p>Shows the items.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[AutoCompleteItem]</code> <p>Items to show.</p> required <code>term</code> <code>str</code> <p>The term to match.</p> required Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def show_items(self, items: list[AutoCompleteItem], term: str):\n    \"\"\"Shows the items.\n\n    Args:\n        items: Items to show.\n        term: The term to match.\n    \"\"\"\n\n    self.active_items = items\n    for i in items:\n        i.grid(row=self.row, sticky=tk.EW)\n        self.row += 1\n\n        i.mark_term(term)\n\n    self.reset_selection()\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.update_all_words","title":"<code>update_all_words()</code>","text":"<p>Updates the words in the menu.</p> Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def update_all_words(self):\n    \"\"\"Updates the words in the menu.\"\"\"\n    for word in self.master.words:\n        if word not in self.get_items_text():\n            self.add_item(word, \"word\")\n\n    for word in self.menu_items:\n        if word.get_text() not in self.master.words and word.get_kind() == \"word\":\n            self.remove_item(word)\n</code></pre>"},{"location":"api-reference/#cupcake.texteditor.autocomplete.AutoComplete.update_completions","title":"<code>update_completions()</code>","text":"<p>Updates and rerenders the completions.</p> Source code in <code>cupcake\\texteditor\\autocomplete\\__init__.py</code> <pre><code>def update_completions(self):\n    \"\"\"Updates and rerenders the completions.\"\"\"\n\n    self.refresh_geometry()\n    self.update_idletasks()\n    self.update_all_words()\n\n    term = self.master.get_current_word()\n\n    exact, starts, includes = [], [], []\n    for i in self.menu_items:\n        if i.get_text() == term:\n            exact.append(i)\n        elif i.get_text().startswith(term):\n            starts.append(i)\n        elif term in i.get_text():\n            includes.append(i)\n    new = list(chain(exact, starts, includes))\n\n    self.hide_all_items()\n    if any(new):\n        self.show_items(new[:10] if len(new) &gt; 10 else new, term)\n    else:\n        self.hide()\n</code></pre>"}]}